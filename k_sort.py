# Задача: k-сортування
# 
# Розглянемо варіант сортування масиву, який ми будемо називати «k-сортуванням».
# При k-сортуванні масиву дозволяється за одну операцію поміняти місцями значення двох елементів масиву 
# з номерами, що відрізняються рівно на k. Таку операцію будемо називати k-обміном.
#
# Задано масив цілих чисел A = [a₁, ..., aₙ]. Ваше завдання полягає в тому, щоб з’ясувати, 
# чи можна за допомогою операцій k-обміну відсортувати масив A. 
# І, якщо можна, то визначити мінімальну кількість k-обмінів, необхідну для впорядкування цього масиву за неспаданням.

def limited_k_bubble_sort(arr, k):
    n = len(arr)
    target = sorted(arr)  # Цільовий масив: відсортований за зростанням
    a = arr[:]             # Копія вхідного масиву, щоб не змінювати оригінал
    swaps = 0              # Лічильник кількості обмінів

    # Обмежуємо кількість проходів n*n на випадок складних перестановок
    for _ in range(n * n): 
        changed = False

        # Проходимо по масиву і виконуємо обміни тільки між елементами на відстані k
        for i in range(n - k):
            if a[i] > a[i + k]:  # Якщо попередній більший — міняємо
                a[i], a[i + k] = a[i + k], a[i]
                swaps += 1       # Збільшуємо лічильник обмінів
                changed = True   # Фіксуємо, що був обмін

        if not changed:
            break  # Якщо за прохід не було обмінів — завершити сортування

    # Перевірка, чи вдалося відсортувати повністю
    if a == target:
        return swaps  # Повертаємо кількість зроблених обмінів
    return -1          # Інакше — сортування за допомогою таких обмінів неможливе

# Зчитування вхідних даних
n = int(input())                     # Кількість елементів у масиві
arr = list(map(int, input().split()))  # Сам масив
k = int(input())                     # Значення k для k-обміну

# Вивід результату
print(limited_k_bubble_sort(arr, k))
